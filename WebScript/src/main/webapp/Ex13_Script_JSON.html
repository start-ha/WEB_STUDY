<!DOCTYPE html>
<html>
<head>
		<meta charset="UTF-8">
		<title>Insert title here</title>
		<script type="text/javascript">
		
		/*  
		javascript 객체지향언어
		객체를 생성하고 사용 ....
		객체 만들떄도 function....

		///////////////////////////////////////////////////
		자바 설계도(클래스) => 재사용성
		class Product extends Object{
				private String carname="pony";
				public Product(){}
				public Product(String carname){
					this.carname= carname;
				}
				public void print(){
					System.out.println(this.carname);
				}
		}
	​	메모리 load ... (new)
		Product p = new Product();
		Product p2 = new Product("pony2");

		p.print();
		p2.print();
		/////////////////////////////////////////////////////

		​

		javaScript >> 객체지향언어(OOP)

		[클래스] 정의 4가지 방법
		
		1. 프로토타입 방식 :  일반적인 클래스 제작 방법
	 	  인스턴스마다 공통된 메서드를 공유해서 사용하는 장점 
	      Jquery 도 prototype 방식으로 설계
	    //함수를 부모에 만들어서 공통된 메서드를 공유 55번줄 >>지금은 안씀. 클래스만들어서씀
	      
	      ​

		//함수만드는 function으로 객체(클래스도 만듬)
		//클래스 이름 앞에 대문자, this.
		function 클래스이름() {  //function Car{}
			this.프로퍼티1 = 초기값;
			this.프로퍼티2 = 초기값;
			
			메서드  ...기능  call(){}
		}

	    (Object) //Heap메모리에 부모를 만들어서 공통된 메서드를 공유
		클래스이름.prototype.메서드1 = function() {
	              (원형,원시)
		}

		클래스이름.prototype.메서드2 = function() {

		}
		​

		var 인스턴스 = new 클래스이름(); 
		var carObj = new Car();   >> 메서드  ...기능  call(){}
		var carObj2 = new Car();  >> 메서드  ...기능  call(){}
		var carObj3 = new Car();  >> 메서드  ...기능  call(){}  why 같은 함수를 각각 따로따로 가지고 있지 ...

		​
		부모타임이 call() 가지고 있으면 .... 같이 사용 
		
		클래스이름.prototype.메서드2 = function() {

		}​

		
		//자바에서 쓰는 방식 (객체마다 함수를 따로따로 만들어 쓸거야 ...)
		2. 함수 방식 : 간단한 클래스 제작 시 사용 //함수 공유하기 싫을때
		인스턴스마다 메서드가 독립적으로 만들어지는 단점
		** 클래스 :  function Car(){ this.name = , this.age=}
		** 함수 :   function car(){}

		​

		function 클래스이름() {
			this.프로퍼티1 = 초기값; //멤버필드명
			this.프로퍼티2 = 초기값;
			this.메서드1 = function() { //함수생성

		    }
			this.메서드2 = function() {

			}
		}


		var 인스턴스 = new 클래스이름(); 
		var carObj = new Car();
		var carObj2 = new Car();
		var carObj3 = new Car();

		​
	   ***************************************************************************
		//가장중요 >> 지금 많이 쓰는 방식, 텍스트형식 
		3. 리터럴 방식 : 자바스크립트 객체 표기법 ( 이기종간의 데이터 호환 ) > JSON
		   클래스 만드는 용도는 아니며 주로 여러개의 매개변수를 그룹으로 묶어 함수의 매개변수로 보낼때
		   정의와 함께 인스턴스가 만들어지는 장점이 있음 단 인스턴스는 오직 하나
		   >> ***********데이터 교환의 목적*******************
	      (초보자에게도 중요 ^^)
		  {"a":"데이터"} //생성과 동시에 객체

		​

		​
	    2015
		4. ECMA6 버전부터 : class 키워드 제공
		//constructor

		class Person {
			constructor(name) {
				this._name = name;

		     }
			sayHi() {
			console.log(`Hi! ${this._name}`);
			}
		}

		[ javascript 객체 생성 ]
		1.오브젝트 리터럴 방식 (객체를 만드는 방법): 클래스 생성과 동시에 객체가 만들어 져요 >>일회성
		1.1 리터럴 방식 >> 제일 간단한 방법 > var obj = {}; //var objarr = [] 배열 
		1.2 JSON 표기 : {} >> JSON: JavaScript Object Notation

		ex) var myObj = { "name":"John", "age":31, "city":"New York" };
				{}자체가 객체
				
		TIP) JSON >> XML (텍스트 기반의 형식화된 문서 제공)
		XML :이기종간의 데이터 호환 (한 때는 서점 : xml webservice)
		무거움...dtd 등.. >> 여행사 항공사간 정보공유가 가능해짐..

		다른 이야기 >> JSON >>xml보완, 텍스트방식, javascript로 객체를 만드는 문법
		객체지향언어 장점 : 설계도 (재사용성)
		*오브젝트 리터럴 방식 : 재사용을 지원하는 않는다 ....
		*설계도를 생성과 동시에 객체 생성(장점 : 편하고 , 빠르다 )
		*설계도를 미리 만들어 놓고 재사용하는 방식은 아니다
		*설계도당 하나의 객체만 생성 사용 (only object)

		var product = {};  //Product p = new Product();

		var product2 = {제품명:'사과',년도:'2018',원산지:'대구'};

		
		var 인스턴스 ={
			프로퍼티:초기값,
			프로퍼티:초기값,
			.....
			메서드:function(){},   //잘 안만들어요 (DATA ....)
			메서드:function(){}....
		}

		​
		리터럴 방식 > 선언과 동시에 인스턴스 자동 생성
		var 인스턴스 = {}
		특징 : 생성자 존재하지 않는다.
		프로퍼티와 메서드만 정의 가능
		단점 : 객체 하나 생성(재사용성 없다) 
		접근방법 : 인스턴스이름.자원 >> product2.제품명 
		
		
		객체생성보다는 데이터호환에 많이 쓰임
		
		*/	
		
		//JSON : 자바스크립트에서 객체를 표시하는 방식..
		let Member = {}; //객체 생성 Car car = new Car();
		
		Member.name = "hong"; //멤버필드를 나중에 추가가능
		console.log(Member);
		
		Member.age = 100;
		
		//함수추가
		Member.print = function(){
			document.write("<br>" + this.name + "/" + this.age + "<br>");
		}

		Member.print();
		
		let Grade = { //멤버필드가 객체를 값으로 가질 수 있다 "객체" : {값}
				"list": {"hong":10, "kim":20, "park":30}, 
				"show": function(){ //함수 안에서 프로퍼티 접근은 무조건 this
					for(let key in this.list){//key값만 뽑음
						document.write(key + ":" + this.list[key] + "<br>");
					//list[key] 값으로 value 표시
					}
				}
		}

		Grade.show();
		
		//xml또는 JSON은 이기종간에 데이터 교환
		//xml 또는 JSON 데이터 담아서 처리하는 목적
		
		
		
		
		
		
		
		
		
		
		
		</script>




</head>
<body>

</body>
</html>